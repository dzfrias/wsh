---STEP 1---
The lexer is fine, so keep it. The parser, however, needs to change. As painful
as it is just go with the 100+ byte AST nodes. The current model of just a
postorder vector isn't working, and it's causing a lot of headaches.

The same feature set that you have currently is okay. Make the basic parser work
with that stuff. The AST should be as friendly as possible. Make sure that the
parser and AST can be extended easily to support more complex constructs later
(if, for, ...).

In summary, rework the parser and AST so that they do the naive implementation.
Even though it's annoying to not do the fancy cool way. That can come later.

---STEP 2---
Write a simple tree-walk interpreter. Again, this can be simple, slow, but
working. There's no need for the complexity of a bytecode VM this early on.
You should have a working shell that can execute commands (with absolute paths).
It should also support basic arithmetic ("echo .(1 + 1)" should print "2").
Strings should also be supported.

---STEP 3---
Make the shell behave a like a shell. Read in $PATH, add shell builtins, allow
environment variables to be set. Do not even think about WebAssembly at this
point.

By this time, you should have a shell that is actually workable, and you should
be able to use it. It should be minimal, though. No aliases, fancy builtins,
globbing, or anything of that sort.

---STEP 4---
Add conveniences to the shell. Globbing, aliases, stuff like that. Again, no
WASM at this point. For a good starting list:

- Aliases
- Globbing
- Execute binaries and enter directores relative to cwd
- Which
- Execute other scripts in current process
- Execute rc file

---STEP 5---
WebAssembly. Builtins should be extended to support executing WASM in the shell
process. This shouldn't actually be that hard, but it kicks off a number of
changes that need to happen in order to get to a working version of the WASM
shell.

This should load a binary into the shell given a name, and the execute it when
the corresponding name is called.

---STEP 6---
WASI support. This should have every common WASI API.

---STEP 7---
WebAssembly extended. Do the cool WebAssembly stuff that makes this project
unique:

- Shell-aided sandboxing
- Virtual directories
- shdiff
- Pass integers and floats to WebAssembly

---MARKER POINT---
This should mark a point in the project where it can be submitted to the fair
confidently.

Anything after this point should be deliberated on later. Some things to think
about in the future:

- Better language
- Implementation of other standard shell conventions
- WIT component implementation
