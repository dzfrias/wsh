use std::{
    env,
    fs::{self, OpenOptions},
    io::Write,
    path::Path,
};

use anyhow::{Context, Result};

use crate::cli::Specgen;

const SPEC_PATH: &str = "./tests/spectests";

pub fn specgen(_args: &Specgen) -> Result<()> {
    env::set_current_dir(SPEC_PATH)
        .context("error changing dir to spec path. Perhaps the path moved?")?;
    fs::write(
        "mod.rs",
        "// This file was generated by xtask specgen\n\nuse shwasi_parser::{Parser, validate};\nuse test_log::test;\n\n",
    )
    .context("error resetting mod.rs")?;
    convert_to_wasm("testsuite", "wasm").context("error converting spectests to WebAssembly")?;

    Ok(())
}

fn convert_to_wasm(path: impl AsRef<Path>, out_path: impl AsRef<Path>) -> Result<()> {
    for entry in path
        .as_ref()
        .read_dir()
        .context("error reading spectests path")?
    {
        let path = entry?.path();
        let name = path
            .file_stem()
            .expect("path should be valid by now")
            .to_str()
            .context("path should be valid utf-8")?;
        // Skip simd tests for now
        if name.starts_with("simd") {
            continue;
        }

        match path.extension().and_then(|ext| ext.to_str()) {
            Some("wasm") => {
                let wasm = fs::read(&path)?;
                let out = out_path.as_ref().join(name).with_extension("wasm");
                fs::write(&out, wasm).context("error writing to generated wasm file")?;
                write_test(out, false)?;
            }
            Some("wat") => {
                let input = fs::read_to_string(&path)?;
                let wasm = wat::parse_str(&input)?;
                let out = out_path.as_ref().join(name).with_extension("wasm");
                fs::write(&out, wasm).context("error writing to generated wasm file")?;
                write_test(out, false)?;
            }
            Some("wast") => {
                let input = fs::read_to_string(&path)?;
                let Ok(buf) = wast::parser::ParseBuffer::new(&input) else {
                    continue;
                };
                let wast: wast::Wast<'_> = match wast::parser::parse(&buf) {
                    Ok(wast) => wast,
                    Err(_) => continue,
                };
                for (i, directive) in wast.directives.into_iter().enumerate() {
                    let is_invalid = matches!(
                        directive,
                        wast::WastDirective::AssertInvalid { .. }
                            | wast::WastDirective::AssertMalformed { .. }
                    );
                    match directive {
                        wast::WastDirective::Wat(mut module)
                        | wast::WastDirective::AssertInvalid {
                            span: _,
                            mut module,
                            message: _,
                        }
                        | wast::WastDirective::AssertMalformed {
                            span: _,
                            mut module,
                            message: _,
                        } => {
                            let Ok(wasm) = module.encode() else {
                                continue;
                            };
                            let name = format!("{name}_{i}");
                            let out = out_path.as_ref().join(&name).with_extension("wasm");
                            fs::write(&out, wasm)
                                .context("error writing to generated wasm file")?;
                            write_test(out, is_invalid)?;
                        }
                        _ => continue,
                    }
                }
            }
            _ => continue,
        }
    }

    Ok(())
}

fn write_test(wasm: impl AsRef<Path>, invalid: bool) -> Result<()> {
    let name = wasm
        .as_ref()
        .file_stem()
        .unwrap()
        .to_str()
        .unwrap()
        .replace('-', "_");
    let wasm_str = wasm.as_ref().to_str().unwrap();
    let test = if invalid {
        format!(
            r#"#[test]
fn invalid_{name}() {{
    let Ok(module) = Parser::new(include_bytes!("{wasm_str}")).read_module() else {{ return; }};
    validate(&module).expect_err("module should have a validation error");
}}

"#
        )
    } else {
        format!(
            r#"#[test]
fn {name}() {{
    let module = Parser::new(include_bytes!("{wasm_str}")).read_module().expect("module should parse with no errors");
    validate(&module).expect("module should validate with no errors");
}}

"#
        )
    };
    let mut file = OpenOptions::new()
        .append(true)
        .open("mod.rs")
        .context("error opening mod.rs")?;
    file.write_all(test.as_bytes())
        .context("error appending to mod.rs")?;
    file.flush().context("error flushing mod.rs")?;

    Ok(())
}
